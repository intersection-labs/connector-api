package io.unequal.reuse.data;
import io.unequal.reuse.util.Arrays;
import io.unequal.reuse.util.Checker;
import io.unequal.reuse.util.IntegrityException;
import static io.unequal.reuse.util.Util.*;



public class Property<T> {

	// TODO add IGNORE_CASE constraint
	public enum Constraint { MANDATORY, READ_ONLY, UNIQUE, AUTO_GENERATED };
	public enum OnDelete { CASCADE, RESTRICT, SET_NULL };
	private final Entity<?> _parent;
	private final Class<T> _type;
	private final String _name;
	private final String _columnName;
	private final ValueGenerator<T> _default;
	private final boolean _mandatory;
	private final boolean _readOnly;
	private final boolean _unique;
	private final boolean _autoGenerated;
	private final boolean _foreignKey;
	private final OnDelete _onDelete;
	private Entity<?> _related;

	// For Entity:
	Property(Entity<?> parent, Class<T> cl, String name, String columnName, ValueGenerator<T> def, OnDelete onDelete, Constraint ... constraints) {
		// Note: null and empty checks are carried out on Entity.addProperty 
		_parent = parent;
		_type = cl;
		_name = name;
		_columnName = columnName;
		_default = def;
		_mandatory = Arrays.contains(Constraint.MANDATORY, constraints);
		_readOnly = Arrays.contains(Constraint.READ_ONLY, constraints);
		_autoGenerated = Arrays.contains(Constraint.AUTO_GENERATED, constraints);
		_unique = Arrays.contains(Constraint.UNIQUE, constraints) || _autoGenerated;
		_foreignKey = Instance.class.isAssignableFrom(cl);
		_onDelete = onDelete;
		// Extra checks:
		if(_autoGenerated && _type != Long.class) {
			throw new IllegalArgumentException("auto-generated properties must be of data type Long");
		}
		if(_autoGenerated && def != null) {
			throw new IllegalArgumentException("auto-generated properties cannot have a default value");
		}
		if(_foreignKey) {
			if(_onDelete == null) {
				throw new IllegalArgumentException("foreign keys require an on-delete constraint");
			}
		}
		// TODO check allowed data types
		// We need to delay fetching the related entity to prevent initialization order problems.
		// Delayed fetching is done in Entity.loadOnFirstUse.
		_related = null;
	}

	public Entity<?> getEntity() {
		return _parent;
	}

	public Class<T> getType() {
		return _type;
	}

	public String getName() {
		return _name;
	}

	public String getColumnName() {
		return _columnName;
	}
	
	public String getFullName() {
		return getEntity().getName()+'.'+getName();
	}
	
	public T getDefaultValue() {
		return _default == null ? null : _default.generate();
	}
	
	public boolean isMandatory() {
		return _mandatory;
	}

	public boolean isReadOnly() {
		return _readOnly;
	}
	
	public boolean isUnique() {
		return _unique;
	}
	
	public boolean isAutoGenerated() {
		return _autoGenerated;
	}
	
	public boolean isForeignKey() {
		return _foreignKey;
	}
	
	public Entity<?> getRelatedEntity() {
		return _related;
	}

	public OnDelete getOnDeleteAction() {
		return _onDelete;
	}
	
	public Predicate isEqualTo(T value) {
		if(value == null) {
			_checkMandatory();
		}
		return new Predicate(this, Predicate.Operator.EQUAL, value==null ? Predicate.NULL : value);
	}

	public Predicate isEqualTo() {
		return new Predicate(this, Predicate.Operator.EQUAL, null);
	}

	public Predicate isNotEqualTo(T value) {
		if(value == null) {
			_checkMandatory();
		}
		return new Predicate(this, Predicate.Operator.NOT_EQUAL, value);
	}

	public Predicate isNotEqualTo() {
		return new Predicate(this, Predicate.Operator.NOT_EQUAL, null);
	}

	public Predicate isGreaterThan(T value) {
		Checker.checkNull(value);
		return new Predicate(this, Predicate.Operator.GREATER_THAN, value);
	}

	public Predicate isLessThan(T value) {
		Checker.checkNull(value);
		return new Predicate(this, Predicate.Operator.LESS_THAN, value);
	}

	public String toString() {
		return getFullName();
	}

	// For Entity:
	void setRelatedEntity(Entity<?> related) {
		if(related == null) {
			throw new IntegrityException();
		}
		_related = related;
	}
	
	// For Connection:
	Object toPrimitive(Object value) {
		if(value == null) {
			_checkMandatory();
			return null;
		}
		if(value.getClass() != _type) {
			throw new IllegalArgumentException(x("expected {} parameter, found {}", _type.getSimpleName(), value.getClass().getSimpleName()));
		}
		// Convert enum to String:
		if(_type.isEnum()) {
			value = value.toString();
		}
		// Convert Constant to int:
		if(Constant.class.isAssignableFrom(_type)) {
			return ((Constant)value).getCode();
		}
		// Convert foreign entities to their id's:
		if(Instance.class.isAssignableFrom(_type)) {
			// Direct conversion to Long:
			if(value instanceof Long) {
				return value;
			}
			Instance<?> i = (Instance<?>)value;
			// Validate that foreign instance key is set:
			if(!i.persisted()) {
				throw new IllegalStateException(x("foreign entity [{}] has not been persisted", i));
			}
			return i.getId();
		}
		return value;
	}
	
	private void _checkMandatory() {
		if(isMandatory()) {
			throw new IllegalArgumentException(x("property '{}' cannot be NULL", getName()));
		}
	}

	// For Instance:
	@SuppressWarnings({ "unchecked", "rawtypes" })
	T toObject(Object value, Connection c) {
		if(value == null) {
			return null;
		}
		// Convert int to Constant:
		if(Constant.class.isAssignableFrom(_type)) {
			return (T)Constant.valueOf(_type, (Long)value);
		}
		// Convert String to enum:
		if(_type.isEnum()) {
			return (T)Enum.valueOf((Class<? extends Enum>)_type, value.toString());
		}
		// Convert foreign key to Instance:
		if(_foreignKey) {
			// TODO use the Connection object here:
			return (T)_related.find((Long)value, c);
		}
		// Deal with empty strings:
		if("".equals(value)) {
			return null;
		}
		return (T)value;
	}
}
