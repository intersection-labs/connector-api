package io.unequal.reuse.data;
import io.unequal.reuse.util.Arrays;
import io.unequal.reuse.util.Checker;
import io.unequal.reuse.util.IntegrityException;
import static io.unequal.reuse.util.Util.*;



public class Property<T> {

	// TODO add IGNORE_CASE constraint
	public enum Constraint { MANDATORY, READ_ONLY, UNIQUE, AUTO_GENERATED };
	public enum OnDelete { CASCADE, RESTRICT, SET_NULL };
	private final Entity<?> _parent;
	private final Class<T> _type;
	private final String _name;
	private final String _columnName;
	private final Generator<T> _default;
	private final boolean _mandatory;
	private final boolean _readOnly;
	private final boolean _unique;
	private final boolean _autoGenerated;
	private final boolean _foreignKey;
	private final OnDelete _onDelete;
	private TypeMapping<?,?> _mapping; 
	private Entity<?> _related;

	// For Entity:
	Property(Entity<?> parent, Class<T> cl, String name, String columnName, Generator<T> def, OnDelete onDelete, Constraint ... constraints) {
		// Note: null and empty checks are carried out on Entity.addProperty 
		_parent = parent;
		_type = cl;
		_name = name;
		_columnName = columnName;
		_default = def;
		_mandatory = Arrays.contains(Constraint.MANDATORY, constraints);
		_readOnly = Arrays.contains(Constraint.READ_ONLY, constraints);
		_autoGenerated = Arrays.contains(Constraint.AUTO_GENERATED, constraints);
		_unique = Arrays.contains(Constraint.UNIQUE, constraints) || _autoGenerated;
		_foreignKey = Instance.class.isAssignableFrom(cl);
		_onDelete = onDelete;
		// Extra checks:
		if(_autoGenerated && _type != Long.class) {
			throw new IllegalArgumentException("auto-generated properties must be of data type Long");
		}
		if(_autoGenerated && def != null) {
			throw new IllegalArgumentException("auto-generated properties cannot have a default value");
		}
		if(_foreignKey) {
			if(_onDelete == null) {
				throw new IllegalArgumentException("foreign keys require an on-delete constraint");
			}
		}
		// Related entities are loaded on Entity.loadInto
		_related = null;
	}

	public Entity<?> getEntity() {
		return _parent;
	}

	public Class<T> getType() {
		return _type;
	}

	public String getName() {
		return _name;
	}

	public String getColumnName() {
		return _columnName;
	}
	
	public String getFullName() {
		return getEntity().getName()+'.'+getName();
	}
	
	public T getDefaultValue() {
		return _default == null ? null : _default.generate();
	}
	
	public boolean isMandatory() {
		return _mandatory;
	}

	public boolean isReadOnly() {
		return _readOnly;
	}
	
	public boolean isUnique() {
		return _unique;
	}
	
	public boolean isAutoGenerated() {
		return _autoGenerated;
	}
	
	public boolean isForeignKey() {
		return _foreignKey;
	}
	
	public Entity<?> getRelatedEntity() {
		return _related;
	}

	public OnDelete getOnDeleteAction() {
		return _onDelete;
	}
	
	public Predicate isEqualTo(T value) {
		if(value == null) {
			_checkMandatory();
		}
		return new Predicate(this, Predicate.Operator.EQUAL, value==null ? Predicate.NULL : value);
	}

	public Predicate isEqualTo() {
		return new Predicate(this, Predicate.Operator.EQUAL, null);
	}

	public Predicate isNotEqualTo(T value) {
		if(value == null) {
			_checkMandatory();
		}
		return new Predicate(this, Predicate.Operator.NOT_EQUAL, value);
	}

	public Predicate isNotEqualTo() {
		return new Predicate(this, Predicate.Operator.NOT_EQUAL, null);
	}

	public Predicate isGreaterThan(T value) {
		Checker.checkNull(value);
		return new Predicate(this, Predicate.Operator.GREATER_THAN, value);
	}

	public Predicate isLessThan(T value) {
		Checker.checkNull(value);
		return new Predicate(this, Predicate.Operator.LESS_THAN, value);
	}

	public String toString() {
		return getFullName();
	}

	// For Entity:
	void setRelatedEntity(Entity<?> related) {
		if(related == null) {
			throw new IntegrityException();
		}
		_related = related;
	}
	
	private void _checkMandatory() {
		if(isMandatory()) {
			throw new IllegalArgumentException(x("property '{}' cannot be NULL", getName()));
		}
	}

	// For Self and Connection:
	TypeMapping<?,?> typeMapping() {
		if(_mapping == null) {
			_mapping = TypeMappings.get(_type);
		}
		return _mapping;
	}

	// For Instance:
	@SuppressWarnings({ "unchecked" })
	T wrap(Object value, Connection c) {
		if(value == null) {
			return null;
		}
		return (T)typeMapping().wrap(value, _type, c);
	}

	// For Connection:
	Object unwrap(Object value) {
		if(value == null) {
			_checkMandatory();
			return null;
		}
		if(value.getClass() != _type) {
			throw new IllegalArgumentException(x("expected {} parameter, found {}", _type.getSimpleName(), value.getClass().getSimpleName()));
		}
		return typeMapping().unwrap(value);
	}
}
