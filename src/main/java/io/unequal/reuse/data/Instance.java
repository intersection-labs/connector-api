package io.unequal.reuse.data;
import java.sql.Timestamp;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import io.unequal.reuse.util.Arrays;
import io.unequal.reuse.util.Checker;
import io.unequal.reuse.util.HashKey;
import io.unequal.reuse.util.Reflection;
import io.unequal.reuse.util.ConstructorNotFoundException;
import io.unequal.reuse.util.ConstructorNotVisibleException;
import io.unequal.reuse.util.IntegrityException;
import static io.unequal.reuse.util.Util.*;


public abstract class Instance<E extends Entity<?>> {

	// TYPE:
	static <I extends Instance<?>> I create(Class<I> c) {
		Checker.nil(c);
		try {
			return Reflection.object(c);
		}
		catch(ConstructorNotFoundException cnfe) {
			throw new IntegrityException(c.getSimpleName()+" needs to have an empty constructor");
		}
		catch(ConstructorNotVisibleException cnfe) {
			throw new IntegrityException(c.getSimpleName()+"'s empty constructor must be visible");
		}
	}
	
	// INSTANCE:
	private final Map<Property<?>,Object> _values;
	private final Map<Property<?>,Object> _updates;
	private boolean _persisted;
	
	protected Instance() {
		_values = new HashMap<>();
		_updates = new HashMap<>();
		_persisted = false;
	}

	public boolean equals(Object o) {
		if(this == o) {
			return true;
		}
		if(o == null) {
			return false;
		}
		if(!(o instanceof Instance)) {
			return false;
		}
		if(o.getClass() == getClass()) {
			return ((Instance<?>)o).id().equals(id());
		}
		return false;
	}
	
	public int hashCode() {
		return new HashKey(getClass(), id()).hashCode();
	}
	
	public String toString() {
		StringBuilder sb = new StringBuilder(entity().instanceName());
		sb.append(':');
		sb.append(' ');
		Iterator<Property<?>> it = entity().propertyMap().values().iterator(); 
		while(it.hasNext()) {
			Property<?> prop = it.next();
			sb.append('[');
			sb.append(prop.name());
			sb.append('=');
			sb.append(get(prop));
			sb.append(']');
			if(it.hasNext()) {
				sb.append(' ');
			}
		}
		return sb.toString();
	}

	public abstract E entity();
	public abstract String describe(Connection c);

	public final Long id() { return get(entity().id); }
	public final Timestamp timeCreated() { return get(entity().timeCreated); }
	public final Timestamp timeUpdated() { return get(entity().timeUpdated); }

	public <T> T get(Property<T> prop, Connection c) {
		Checker.nil(prop);
		_checkProperty(prop);
		if(prop.foreignKey()) {
			Checker.nil(c);
		}
		// Check if we have the object cached:
		// (we need to use containsKey to cater for updates to NULL)
		if(_updates.containsKey(prop)) {
			return prop.wrap(_updates.get(prop), c);
		}
		// We don't:
		return prop.wrap(_values.get(prop), c);
	}

	public <T> T get(Property<T> prop) {
		return get(prop, (Connection)null);
	}

	protected <T> Instance<E> set(Property<T> prop, T value) {
		Checker.nil(prop);
		_checkProperty(prop);
		// Prevent updates to internal properties:
		if(Arrays.contains(prop, entity().id, entity().timeCreated, entity().timeUpdated)) {
			throw new IllegalArgumentException(x("cannot set property '{}'", prop.name()));
		}
		// TODO remove this check. Should be enforced by the compiler
		// Validate data type (it should be enforced by the compiler):
		if(value != null) {
			if(!prop.type().isAssignableFrom(value.getClass())) {
				throw new IntegrityException(value.getClass());
			}
		}
		// TODO Validate that data type is accepted by GAE: (note this will be done on Property, do we really need it here?		
		// Validate format:
		// TODO
		// if(f.getValidator() != null) {
		// Validate mandatory constraint:
		if(value == null && prop.mandatory()) {
			throw new MandatoryConstraintException(prop);
		}
		// Validate read-only constraint:
		if(persisted()) {
			if(prop.readOnly()) {
				throw new ReadOnlyConstraintException(prop, value);
			}
		}
		// Validate auto-generated constraint:
		if(prop.autoGenerated()) {
			throw new AutoGenConstraintException(prop, value);
		}
		// Validate foreign key:
		if(prop.foreignKey()) {
			Instance<?> i = (Instance<?>)value;
			if(!i.persisted()) {
				throw new IllegalStateException(x("foreign entity [{}] has not been persisted", i));
			}
		}
		// Track update:
		Object unwrapped = prop.unwrap(value);
		_updates.put(prop,  unwrapped);
		// Check if the property is being set to its current value:
		_removeIfNotUpdated(prop, unwrapped);
		return this;
	}
	
	// For QueryResult:
	Object unwrapped(Property<?> prop) {
		Checker.nil(prop);
		Object value = _updates.get(prop);
		if(value != null) {
			return value;
		}
		return _values.get(prop);
	}

	public boolean updated() {
		return _updates.size() > 0;
	}

	public boolean persisted() {
		return _persisted;
	}
	
	// For Connection:
	void primaryKey(Long key) {
		Checker.min(key, 1);
		_values.put(entity().id, key);
		_persisted = true;
	}

	// For Entity:
	Set<Map.Entry<Property<?>,Object>> updates() {
		return new HashMap<>(_updates).entrySet();
	}

	// For Entity:
	Set<Property<?>> updatedProperties() {
		return new HashSet<>(_updates.keySet());
	}

	// For Entity:
	// TODO not used
	void as(Instance<?> i) {
		_updates.clear();
		_updates.putAll(i._updates);
		// Remove any redundant updates:
		for(Property<?> prop : i._updates.keySet()) {
			_removeIfNotUpdated(prop, _updates.get(prop));
		}
	}

	// For Entity:
	boolean updated(Property<?> prop) {
		return _updates.containsKey(prop);
	}

	// For Entity:
	void flush() {
		_values.putAll(_updates);
		_updates.clear();
	}

	// For Connection:
	void update(Property<?> prop, Object value, boolean flush) {
		if(flush) {
			_values.put(prop, value);
		}
		else {
			_updates.put(prop, value);
		}
	}
	
	private void _checkProperty(Property<?> prop) {
		// Check if setting a property that pertains to this entity:
		if(!entity().propertyMap().containsValue(prop)) {
			throw new IllegalArgumentException(x("property '{}' cannot be used in entity '{}'", prop.fullName(), entity().name()));
		}
	}

	private void _removeIfNotUpdated(Property<?> prop, Object value) {
		if(_values.containsKey(prop)) {
			Object current = _values.get(prop);
			if(value == null) {
				if(current == null) {
					_updates.remove(prop);
				}
			}
			else {
				if(value.equals(current)) {
					_updates.remove(prop);
				}
			}
		}
	}
}
